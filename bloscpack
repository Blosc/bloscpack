#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim :set ft=py:

import sys
import os.path as path
import blosc
import argparse

""" Command line interface to Blosc via python-blosc """

version = '0.1.0-dev'
author = 'Valentin Haenel <valentin.haenel@gmx.>'

EXTENSION = '.blp'
DEFAULT_TYPESIZE = 4
DEFAULT_CLEVEL = 7
DEFAULT_SHUFFLE = True

def create_parser():
    """ Create and return the parser.

    Useful to have this in a function for interactive debugging. If you need to
    import this file do:

        $ ln -s bloscpack bloscpack.py

    """
    parser = argparse.ArgumentParser(
            description='command line de/compression with blosc')
    # accepts a single input file for now
    parser.add_argument('file_',
            metavar='<file>',
            type=str,
            nargs=1,
            help='file to be de/compressed')
    # print version of bloscpack, python-blosc and blosc itself
    parser.add_argument('--version',
            action='version',
            version='%(prog)s: ' + ("'%s'\n" % version) + \
                    "python-blosc: '%s'\n"   % blosc.version.__version__ +\
                    "blosc: '%s'\n"          % blosc.BLOSC_VERSION_STRING
            )
    parser.add_argument('--verbose',
            action='store_true',
            default=False,
            help='be verbose about actions')
    group = parser.add_argument_group(title='compression only')
    group.add_argument( '--typesize',
            metavar='<size>',
            default=None,
            type=int,
            help='typesize for blosc, default = %d' %
            DEFAULT_TYPESIZE)
    group.add_argument( '--clevel',
            default=None,
            choices=range(10),
            type=int,
            help='compression level, default = %d' %
            DEFAULT_CLEVEL)
    group.add_argument( '--no-shuffle',
            action='store_false',
            default=None,
            dest='no_shuffle',
            help='deactivate shuffle')
    # options to do heavy lifting
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-c',
            '--compress',
            action='store_true',
            dest='compress',
            default=False,
            help='perform compression on <file>')
    group.add_argument('-d',
            '--decompress',
            action='store_true',
            dest='decompress',
            default=False,
            help='perform decompression on <file>')
    return parser

if __name__ == '__main__':
    parser = create_parser()
    args = parser.parse_args()
    def print_verbose(message):
        if args.verbose:
            print('%s: %s' % (parser.prog, message))
    print_verbose('command line argument parsing complete')
    print_verbose('command line arguments are: ')
    for arg,val in vars(args).iteritems():
        print_verbose('\t%s: %s' % (arg,str(val)))
    file_ = args.file_[0]

    # argparse takes care of the mutual exclusivity of -c and -d
    if args.compress:
        print_verbose('getting ready for compression')
        input_file = file_
        output_file = file_ + EXTENSION
        blosc_function = blosc.compress
        typesize = args.typesize \
            if args.typesize is not None \
            else DEFAULT_TYPESIZE
        clevel = args.clevel \
            if args.clevel is not None \
            else DEFAULT_CLEVEL
        shuffle = False \
            if args.no_shuffle is False \
            else DEFAULT_SHUFFLE
        blosc_args = [typesize, clevel, shuffle]
        print_verbose('blosc args are:')
        for arg_val in zip(['typesize', 'clevel', 'shuffle'],
                           map(str, blosc_args)):
            print_verbose('\t%s: %s' % arg_val)
    elif args.decompress:
        print_verbose('getting ready for decompression')
        for arg,switch in [(args.typesize, '--typesize'),
                           (args.clevel, '--clevel'),
                           (args.no_shuffle, '--no-shuffle')]:
            if arg is not None:
                parser.error("'%s' makes no sense when decompressing" % switch)
        input_file = file_
        output_file = file_
        # remove the extension for output file
        if file_.endswith(EXTENSION):
            output_file = input_file[:-len(EXTENSION)]
        else:
            parser.error("input file '%s' does not end with '%s'" %
                    (input_file, EXTENSION))
        blosc_function = blosc.decompress
        blosc_args = []
    else:
        # we should never reach this
        parser.error('You found the easter-egg, please contact the autor')
    # check files exist/don't exist
    if not path.exists(input_file):
        parser.error("input file '%s' does not exist!" % input_file)
    print_verbose('input file is: %s' % input_file)
    if path.exists(output_file):
        parser.error("output file '%s' exists!" % output_file)
    print_verbose('output file is: %s' % output_file)
    # use context managers and functions pointers to do the heavy lifting
    with open(input_file, 'rb') as input_fp, \
                open(output_file, 'wb') as output_fp:
        in_data = input_fp.read()
        len_in = len(in_data)
        print_verbose('input buffer length: %d' % len_in)
        out_data = blosc_function(in_data, *blosc_args)
        len_out = len(out_data)
        print_verbose('output buffer length: %d' % len_out)
        print_verbose('ratio: %f' % (float(len_out)/float(len_in)))
        output_fp.write(out_data)
    print_verbose('done')
