#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim :set ft=py:

""" Command line interface to Blosc via python-blosc """

from __future__ import division

import os.path as path
import argparse
import struct
import math
import nose
import nose.tools as nt
import blosc

version = '0.1.0-dev'
author = 'Valentin Haenel <valentin.haenel@gmx.>'

EXTENSION = '.blp'
MAGIC = 'blpk'
DEFAULT_TYPESIZE = 4
DEFAULT_CLEVEL = 7
DEFAULT_SHUFFLE = True

def create_parser():
    """ Create and return the parser.

    Useful to have this in a function for interactive debugging. If you need to
    import this file do:

        $ ln -s bloscpack bloscpack.py

    """
    parser = argparse.ArgumentParser(
            description='command line de/compression with blosc',
            formatter_class=argparse.RawTextHelpFormatter)
    # accepts a single input file for now
    parser.add_argument('in_file',
            metavar='<in_file>',
            type=str,
            help='file to be de/compressed')
    parser.add_argument('out_file',
            metavar='<out_file>',
            type=str,
            nargs='?',
            default=None,
            help='file to de/compress to')
    # print version of bloscpack, python-blosc and blosc itself
    parser.add_argument('--version',
            action='version',
            version='%(prog)s:\t' + ("'%s'\n" % version) + \
                    "python-blosc:\t'%s'\n"   % blosc.version.__version__ + \
                    "blosc:\t\t'%s'\n"        % blosc.BLOSC_VERSION_STRING)
    parser.add_argument('--verbose',
            action='store_true',
            default=False,
            help='be verbose about actions')
    parser.add_argument('--force',
            action='store_true',
            default=False,
            help='disable overwrite checks for existing files\n' + \
            '(use with caution)')
    class CheckThreadOption(argparse.Action):
        def __call__(self, parser, namespace, value, option_string=None):
            if not 1 <= value <= blosc.BLOSC_MAX_THREADS:
                parser.error('%s must be 1 <= n <= %d'
                        % (option_string, blosc.BLOSC_MAX_THREADS))
            setattr(namespace, self.dest, value)
    parser.add_argument('--nthreads',
            metavar='[1, %d]' % blosc.BLOSC_MAX_THREADS,
            action=CheckThreadOption,
            default=blosc.ncores,
            type=int,
            dest='nthreads',
            help='set number of thereads, default = ncores (%(default)s)')
    group = parser.add_argument_group(title='compression only')
    group.add_argument('--typesize',
            metavar='<size>',
            default=None,
            type=int,
            help='typesize for blosc, default = %d' %
            DEFAULT_TYPESIZE)
    group.add_argument('--clevel',
            default=None,
            choices=range(10),
            metavar='[0, 9]',
            type=int,
            help='compression level, default = %d' %
            DEFAULT_CLEVEL)
    group.add_argument('--no-shuffle',
            action='store_false',
            default=None,
            dest='no_shuffle',
            help='deactivate shuffle')
    group = parser.add_argument_group(title='decompression only')
    group.add_argument('--no-check-extension',
            action='store_true',
            default=None,
            dest='no_check_extension',
            help='disable checking input file for extension (*.blp)\n' +
            '(requires use of <out_file>)')
    # options to do heavy lifting
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-c',
            '--compress',
            action='store_true',
            dest='compress',
            default=False,
            help='perform compression on <in_file>')
    group.add_argument('-d',
            '--decompress',
            action='store_true',
            dest='decompress',
            default=False,
            help='perform decompression on <in_file>')
    return parser

def read_blosc_header(buffer_):
    """ Read and decode header from compressed Blosc buffer.

    Parameters
    ----------
    buffer_ : string of bytes
        the compressed buffer

    Returns
    -------
    settings : dict
        a dict containing the settings from Blosc

    Notes
    -----

    The Blosc 1.1.3 header is 16 bytes as follows:

    |-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|
      ^   ^   ^   ^ |     nbytes    |   blocksize   |    ctbytes    |
      |   |   |   |
      |   |   |   +--typesize
      |   |   +------flags
      |   +----------versionlz
      +--------------version

    The first four are simply bytes, the last three are are each unsigned ints
    (uint32) each occupying 4 bytes. The header is always littel-endian.

    """
    def decode_byte(byte):
        return int(byte.encode('hex'), 16)
    def decode_uint32(fourbyte):
        return struct.unpack('<I', fourbyte)[0]
    return {'version': decode_byte(buffer_[0]),
            'versionlz': decode_byte(buffer_[1]),
            'flags': decode_byte(buffer_[2]),
            'typesize': decode_byte(buffer_[3]),
            'nbytes': decode_uint32(buffer_[4:8]),
            'blocksize': decode_uint32(buffer_[8:12]),
            'ctbytes': decode_uint32(buffer_[12:16])}

class ChunkingException(BaseException):
    pass

def _nchunks(in_file_size, nchunks=None):
    """ Determine chunking for an input file.

    Parameters
    ----------

    in_file_size : int
        the size of the input file
    nchunks : int
        the number of chunks desired by the user

    Returns
    -------
    nchunks, chunk_size, last_chunk_size

    nchunks : int
        the number of chunks
    chunk_size : int
        the size of each chunk in bytes
    last_chunk_size : int
        the size of the last chunk

    Raises
    ------
    ChunkingException
        if the chunk_size resulting from nchunks makes the chunks larger than
        permitted by BLOSC_MAX_BUFFERSIZE

    """
    nchunks =  int(math.ceil(in_file_size/blosc.BLOSC_MAX_BUFFERSIZE)) \
            if nchunks is None else nchunks
    chunk_size = in_file_size//nchunks
    last_chunk_size = chunk_size + in_file_size%nchunks
    if chunk_size > blosc.BLOSC_MAX_BUFFERSIZE \
            or last_chunk_size > blosc.BLOSC_MAX_BUFFERSIZE:
        raise ChunkingException(
            "Your value of 'nchunks' would lead to chunk sizes bigger than " +\
            "'BLOSC_MAX_BUFFERSIZE', please use something smaller.\n" +\
            "proposed nchunks : %d\n" % nchunks +\
            "chunk_size : %d\n" % chunk_size +\
            "last_chunk_size : %d\n" % last_chunk_size +\
            "BLOSC_MAX_BUFFERSIZE : %d\n" % blosc.BLOSC_MAX_BUFFERSIZE)
    return nchunks, chunk_size, last_chunk_size

def test_nchunks():
    nt.assert_equal((2, 3, 4), _nchunks(7, nchunks=2))
    nt.assert_raises(ChunkingException,
            _nchunks, blosc.BLOSC_MAX_BUFFERSIZE*4, nchunks=2)

def create_bloscpack_header(nchunks):
    # this will fail if nchunks is larger than the max of an unsigned int
    return (MAGIC + struct.pack('<I', nchunks))

def test_create_bloscpack_header():
    nt.assert_equal('%s\x00\x00\x00\x00' % MAGIC, create_bloscpack_header(0))

def pack_file(in_file, out_file, blosc_args, nchunks=None):
    # calculate chunk sizes
    in_file_size = path.getsize(in_file)
    print('Input file size: %d' % in_file_size)
    try:
        nchunks, chunk_size, last_chunk_size = _nchunks(in_file_size, nchunks)
    except ChunkingException as e:
        pass
    print('nchunks: %d' % nchunks)
    print('chunk_size: %d bytes' % chunk_size)
    print('last_chunk_size: %d bytes' % last_chunk_size)
    # calculate header
    bloscpack_header = create_bloscpack_header(nchunks)
    print('bloscpack_header: %s' % repr(bloscpack_header))
    # write the chunks to the file
    with open(in_file, 'rb') as input_fp, \
         open(out_file, 'wb') as output_fp:
        output_fp.write(bloscpack_header)
        for bytes_to_read in ([chunk_size] * (nchunks - 1)) + [last_chunk_size]:
            current_chunk = input_fp.read(bytes_to_read)
            compressed = blosc.compress(current_chunk, *blosc_args)
            output_fp.write(compressed)
    out_file_size = path.getsize(out_file)
    print('Output file size: %d' % out_file_size)

if __name__ == '__main__':
    parser = create_parser()
    args = parser.parse_args()
    def print_verbose(message):
        """ verbose printing as closure """
        if args.verbose:
            print('%s: %s' % (parser.prog, message))
    print_verbose('command line argument parsing complete')
    print_verbose('command line arguments are: ')
    for arg, val in vars(args).iteritems():
        print_verbose('\t%s: %s' % (arg, str(val)))
    in_file = args.in_file
    out_file = args.out_file if args.out_file is not None else None

    # argparse takes care of the mutual exclusivity of -c and -d
    if args.compress:
        print_verbose('getting ready for compression')
        for arg, switch in [(args.no_check_extension, '--no-check-extension')]:
            if arg is not None:
                parser.error("'%s' makes no sense when compressing" % switch)
        out_file = in_file + EXTENSION if out_file is None else out_file
        blosc_function = blosc.compress
        typesize = args.typesize \
            if args.typesize is not None \
            else DEFAULT_TYPESIZE
        clevel = args.clevel \
            if args.clevel is not None \
            else DEFAULT_CLEVEL
        shuffle = False \
            if args.no_shuffle is False \
            else DEFAULT_SHUFFLE
        blosc_args = [typesize, clevel, shuffle]
        print_verbose('blosc args are:')
        for arg_val in zip(['typesize', 'clevel', 'shuffle'],
                           map(str, blosc_args)):
            print_verbose('\t%s: %s' % arg_val)
    elif args.decompress:
        print_verbose('getting ready for decompression')
        for arg, switch in [(args.typesize, '--typesize'),
                           (args.clevel, '--clevel'),
                           (args.no_shuffle, '--no-shuffle')]:
            if arg is not None:
                parser.error("'%s' makes no sense when decompressing" % switch)
        # remove the extension for output file
        if args.no_check_extension:
            if out_file is None:
                parser.error('--no-check-extension requires use of <out_file>')
        else:
            if in_file.endswith(EXTENSION):
                out_file = in_file[:-len(EXTENSION)] \
                        if out_file is None else out_file
            else:
                parser.error("input file '%s' does not end with '%s'" %
                        (in_file, EXTENSION))
        blosc_function = blosc.decompress
        blosc_args = []
    else:
        # we should never reach this
        parser.error('You found the easter-egg, please contact the autor')
    print_verbose('input file is: %s' % in_file)
    print_verbose('output file is: %s' % out_file)
    # check files exist/don't exist
    if not path.exists(in_file):
        parser.error("input file '%s' does not exist!" % in_file)
    if path.exists(out_file):
        if not args.force:
            parser.error("output file '%s' exists!" % out_file)
        else:
            print_verbose("overwriting exisiting file: %s" % out_file)
    # set number of threads
    if args.nthreads != blosc.ncores:
        blosc.set_nthreads(args.nthreads)
    print_verbose('using %d thread%s' %
            (args.nthreads, 's' if args.nthreads > 1 else ''))
    # use context managers and functions pointers to do the heavy lifting
    with open(in_file, 'rb') as input_fp, \
         open(out_file, 'wb') as output_fp:
        in_data = input_fp.read()
        len_in = len(in_data)
        print_verbose('input buffer length: %d' % len_in)
        out_data = blosc_function(in_data, *blosc_args)
        len_out = len(out_data)
        print_verbose('output buffer length: %d' % len_out)
        print_verbose('ratio: %f' % (float(len_out) / float(len_in)))
        output_fp.write(out_data)
    print_verbose('done')
