#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim :set ft=py:

""" Command line interface to Blosc via python-blosc """

import os.path as path
import blosc
import argparse

version = '0.1.0-dev'
author = 'Valentin Haenel <valentin.haenel@gmx.>'

EXTENSION = '.blp'
DEFAULT_TYPESIZE = 4
DEFAULT_CLEVEL = 7
DEFAULT_SHUFFLE = True

def create_parser():
    """ Create and return the parser.

    Useful to have this in a function for interactive debugging. If you need to
    import this file do:

        $ ln -s bloscpack bloscpack.py

    """
    parser = argparse.ArgumentParser(
            description='command line de/compression with blosc',
            formatter_class=argparse.RawTextHelpFormatter)
    # accepts a single input file for now
    parser.add_argument('in_file',
            metavar='<in_file>',
            type=str,
            help='file to be de/compressed')
    parser.add_argument('out_file',
            metavar='[<out_file>]',
            type=str,
            nargs='?',
            default=None,
            help='file to de/compress to')
    # print version of bloscpack, python-blosc and blosc itself
    parser.add_argument('--version',
            action='version',
            version='%(prog)s:\t' + ("'%s'\n" % version) + \
                    "python-blosc:\t'%s'\n"   % blosc.version.__version__ +\
                    "blosc:\t\t'%s'\n"          % blosc.BLOSC_VERSION_STRING
            )
    parser.add_argument('--verbose',
            action='store_true',
            default=False,
            help='be verbose about actions')
    parser.add_argument('--force',
            action='store_true',
            default=False,
            help='disable overwrite checks for existing files\n'+\
            '(use with caution)')
    class ThreadAction(argparse.Action):
        def __call__(self, parser, namespace, value, option_string=None):
            if value < 1:
                parser.error('%s must be greater than zero' % option_string)
            setattr(namespace, self.dest, value)
    parser.add_argument('--nthreads',
            metavar='<num>',
            action=ThreadAction,
            default=blosc.ncores,
            type=int,
            dest='nthreads',
            help='set number of thereads, default = ncores (%(default)s)')
    group = parser.add_argument_group(title='compression only')
    group.add_argument( '--typesize',
            metavar='<size>',
            default=None,
            type=int,
            help='typesize for blosc, default = %d' %
            DEFAULT_TYPESIZE)
    group.add_argument( '--clevel',
            default=None,
            choices=range(10),
            type=int,
            help='compression level, default = %d' %
            DEFAULT_CLEVEL)
    group.add_argument( '--no-shuffle',
            action='store_false',
            default=None,
            dest='no_shuffle',
            help='deactivate shuffle')
    group = parser.add_argument_group(title='decompression only')
    group.add_argument( '--no-check-extension',
            action='store_true',
            default=None,
            dest='no_check_extension',
            help='disable checking input file for extension (*.blp)\n'+
            '(requires use of <out_file>)')
    # options to do heavy lifting
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-c',
            '--compress',
            action='store_true',
            dest='compress',
            default=False,
            help='perform compression on <in_file>')
    group.add_argument('-d',
            '--decompress',
            action='store_true',
            dest='decompress',
            default=False,
            help='perform decompression on <in_file>')
    return parser

if __name__ == '__main__':
    parser = create_parser()
    args = parser.parse_args()
    def print_verbose(message):
        if args.verbose:
            print('%s: %s' % (parser.prog, message))
    print_verbose('command line argument parsing complete')
    print_verbose('command line arguments are: ')
    for arg, val in vars(args).iteritems():
        print_verbose('\t%s: %s' % (arg, str(val)))
    in_file = args.in_file
    out_file = args.out_file if args.out_file is not None else None

    # argparse takes care of the mutual exclusivity of -c and -d
    if args.compress:
        print_verbose('getting ready for compression')
        for arg, switch in [(args.no_check_extension, '--no-check-extension')]:
            if arg is not None:
                parser.error("'%s' makes no sense when compressing" % switch)
        out_file = in_file + EXTENSION if out_file is None else out_file
        blosc_function = blosc.compress
        typesize = args.typesize \
            if args.typesize is not None \
            else DEFAULT_TYPESIZE
        clevel = args.clevel \
            if args.clevel is not None \
            else DEFAULT_CLEVEL
        shuffle = False \
            if args.no_shuffle is False \
            else DEFAULT_SHUFFLE
        blosc_args = [typesize, clevel, shuffle]
        print_verbose('blosc args are:')
        for arg_val in zip(['typesize', 'clevel', 'shuffle'],
                           map(str, blosc_args)):
            print_verbose('\t%s: %s' % arg_val)
    elif args.decompress:
        print_verbose('getting ready for decompression')
        for arg, switch in [(args.typesize, '--typesize'),
                           (args.clevel, '--clevel'),
                           (args.no_shuffle, '--no-shuffle')]:
            if arg is not None:
                parser.error("'%s' makes no sense when decompressing" % switch)
        # remove the extension for output file
        if args.no_check_extension:
            if out_file is None:
                parser.error('--no-check-extension requires use of <out_file>')
        else:
            if in_file.endswith(EXTENSION):
                out_file = in_file[:-len(EXTENSION)] \
                        if out_file is None else out_file
            else:
                parser.error("input file '%s' does not end with '%s'" %
                        (in_file, EXTENSION))
        blosc_function = blosc.decompress
        blosc_args = []
    else:
        # we should never reach this
        parser.error('You found the easter-egg, please contact the autor')
    print_verbose('input file is: %s' % in_file)
    print_verbose('output file is: %s' % out_file)
    # check files exist/don't exist
    if not path.exists(in_file):
        parser.error("input file '%s' does not exist!" % in_file)
    if path.exists(out_file):
        if not args.force:
            parser.error("output file '%s' exists!" % out_file)
        else:
            print_verbose("overwriting exisiting file: %s" % out_file)
    # set number of threads
    if args.nthreads != blosc.ncores:
        blosc.set_nthreads(args.nthreads)
    print_verbose('using %d thread%s' %
            (args.nthreads, 's' if args.nthreads > 1 else ''))
    # use context managers and functions pointers to do the heavy lifting
    with open(in_file, 'rb') as input_fp, \
                open(out_file, 'wb') as output_fp:
        in_data = input_fp.read()
        len_in = len(in_data)
        print_verbose('input buffer length: %d' % len_in)
        out_data = blosc_function(in_data, *blosc_args)
        len_out = len(out_data)
        print_verbose('output buffer length: %d' % len_out)
        print_verbose('ratio: %f' % (float(len_out)/float(len_in)))
        output_fp.write(out_data)
    print_verbose('done')
